<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>UploadMe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link href="/fa/css/font-awesome.min.css" rel="stylesheet">
<link href="/bootstrap.min.css" rel="stylesheet">
<style>
body {
	color: #333;
}
.red {
	color: red;
}
.green {
	color: green;
}
#drop_zone {
	background-color: #fafafa;
    border: 2px dashed gray;
    -moz-border-radius: 5px;
    -webkit-border-radius: 5px;
    border-radius: 5px;
    padding: 25px;
    text-align: center;
    font: 20pt bold 'Vollkorn';
    cursor: pointer;
}
#files {
	display: none;
}
#list {
	margin-top: 10px;
}
#list ul {
	list-style-type: none;
}

/* progress */
.progress_bar {
	display: inline-block;
	    width: 200px;
margin: 10px 0;
padding: 3px;
border: 1px solid #000;
font-size: 14px;
-moz-transition: opacity 1s linear;
-o-transition: opacity 1s linear;
-webkit-transition: opacity 1s linear;
}
.progress_bar.loading {
opacity: 1.0;
}
.progress_bar .percent {
background-color: #99ccff;
height: auto;
width: 0;
}
</style>
 </head>
 <body>
 <div class="container">
 	<h1>Uploadme</h1>
 	<input type="file" id="files" multiple />
	<div id="drop_zone">
		<p><i class="fa-5x fa fa-cloud-upload"></i></p>
		Drop MP3/WAV here (or click to select)
	</div>
	<output id="list">Loading assets..</output>
</div>

<script>
	"use strict";
  var queue = []; 
  var uniq = 0;
  var whitelist = ['audio/wav', 'audio/mp3'];

var xhr = new XMLHttpRequest();
xhr.open('GET', '/action/uploads', true);
xhr.onload = function(e) {
	// TODO: Error handle?
	if (this.status == 200) {
	  console.log("xhr", this.responseText);
	  var obj = JSON.parse(this.responseText);
	  console.log(obj);
	  var output = '';
	  for (var i = 0; i < obj.length; i++) {
	  	var name = obj[i];
	  	output += '<li><strong class="green"><i class="fa fa-check-circle" aria-hidden="true"></i> ' + htmlEscape(name) + '</strong></li>';
	  }
	  document.getElementById('list').innerHTML = '<ul>' + output + '</ul>';
	}
};
xhr.send();

function htmlEscape(str) {
    return str
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}

  function prep(files) {
    for (var i = 0, f; f = files[i]; i++) {
      console.log(f);
      if (whitelist.indexOf(f.type) === -1) {
      	output = '<li class="red"><strong><i class="fa fa-exclamation-triangle" aria-hidden="true"></i> Ignored: ' + htmlEscape(f.name) + '</strong>';
      	document.getElementById('list').children[0].innerHTML += output;
      	return;
      }

      var id = 'result_' + uniq;
      uniq++;
      console.log("Z", id);
      /*queue.push({
      	id: 'result_' + output.length,
      	f: f
      });*/

      	// TODO: Some queue?
	  	var stop = chunkedRead(f, id, function(f, chunk, i, total, id) {
	  		var xhr = new XMLHttpRequest();
	      	xhr.open('POST', '/action/uploads/chunk?f='+ encodeURIComponent(f.name) + '&i=' + i + "&total=" + total, true);
	      	xhr.setRequestHeader('Content-Type', 'application/octet-stream');
	      	xhr.onload = function(e) {
	      		// TODO: Error handle?
	      		if (xhr.readyState == 4) { 
				    if (this.status == 200) {
				      console.log("xhr", this.responseText);

				      // (5/10)*100
				      var percent = ((i+1) / total) * 100;
				      document.getElementById(id + '_step').style.width = percent + '%';
				      document.getElementById(id + '_step').innerHTML = percent + '%';
				      // TODO: Update UI?
				      if (percent == 100) {
						document.getElementById(id).innerHTML = '<strong class="green"><i class="fa fa-check-circle" aria-hidden="true"></i> ' + htmlEscape(f.name) + '</strong>';
				      }
				    } else {
				    	document.getElementById(id).innerHTML = '<strong class="red"><i class="fa fa-exclamation" aria-hidden="true"></i> ' + htmlEscape(f.name) + '</strong>';
				    }
				}
			};
			xhr.onerror = function () {
				document.getElementById(id).innerHTML = '<strong class="red"><i class="fa fa-exclamation" aria-hidden="true"></i> ' + htmlEscape(f.name) + '</strong>';
				stop();
			};
	  		xhr.send(chunk);
	  	}, function(f, id) {
	  	});

      var output =
      	//'<li id=' + id + '><strong><i class="fa fa-pause-circle" aria-hidden="true"></i> ' + htmlEscape(f.name) + '</strong></li>'
      	'<li id=' + id + '><strong><i class="fa fa-circle-o-notch fa-spin fa-fw" aria-hidden="true"></i> ' + htmlEscape(f.name) + '</strong> <div class="progress_bar"><div id="' + id +'_step" class="percent">0%</div></div></li>'
      ;
      document.getElementById('list').children[0].innerHTML += output;
    }
  }
  // fsize=115356 
  //chunk=1048576

  // https://stackoverflow.com/questions/14438187/javascript-filereader-parsing-long-file-in-chunks#28318964
  function chunkedRead(file, id, callback, cbDone) {
    var chunkSize  = 1 * 1024*1024; // 1mb
    var offset     = 0;
    var chunkReaderBlock = null;
    var i = 0;
    var stop = false;
    console.log('chunkedRead.begin', file.name, 'chunks', Math.ceil(file.size / chunkSize));

    var readEventHandler = function(evt) {
        if (evt.target.error == null) {
        	console.log('chunkedRead.chunk', file.name, 'offset', offset, 'chunk', offset+evt.target.result.byteLength, 'total', file.size);
            offset += evt.target.result.byteLength;
            //offset += chunkSize;
            callback(file, evt.target.result, i, Math.ceil(file.size / chunkSize), id);
            i++;
        } else {
            console.log("Read error: " + evt.target.error);
            return;
        }
        if (offset >= file.size) {
            console.log("chunkedRead.done");
            cbDone(file, id);
            return;
        }

        // off to the next chunk
        chunkReaderBlock(offset, chunkSize, file);
    }

    chunkReaderBlock = function(_offset, length, _file) {
    	if (stop) {
    		console.log("Cancel");
    		return;
    	}
        var r = new FileReader();
        var blob = _file.slice(_offset, length + _offset);
        r.onloadend = readEventHandler;
        //r.readAsBinaryString(blob);
        r.readAsArrayBuffer(blob);
    }

    // now let's start the read with the first block
    chunkReaderBlock(offset, chunkSize, file);
    return function() {
    	stop = true;
    }
  }

  function errorHandler(evt) {
    switch(evt.target.error.code) {
      case evt.target.error.NOT_FOUND_ERR:
        alert('File Not Found!');
        break;
      case evt.target.error.NOT_READABLE_ERR:
        alert('File is not readable');
        break;
      case evt.target.error.ABORT_ERR:
        break; // noop
      default:
        alert('An error occurred reading this file.');
    };
  }
  function updateProgress(evt) {
    // evt is an ProgressEvent.
    if (evt.lengthComputable) {
      var percentLoaded = Math.round((evt.loaded / evt.total) * 100);
      // Increase the progress bar length.
      if (percentLoaded < 100) {
        progress.style.width = percentLoaded + '%';
        progress.textContent = percentLoaded + '%';
      }
    }
  }

  function handleFileSelect(evt) {
    evt.stopPropagation();
    evt.preventDefault();

    prep(evt.dataTransfer.files);
  }
  function handleFileChange(evt) {
    prep(evt.target.files);
  }

  function handleFileClick(evt) {
  	document.getElementById('files').click();
  }

  function handleDragOver(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
  }

  // Setup the dnd listeners.
  var dropZone = document.getElementById('drop_zone');
  dropZone.addEventListener('dragover', handleDragOver, false);
  dropZone.addEventListener('drop', handleFileSelect, false);
  dropZone.addEventListener('click', handleFileClick, false);

  document.getElementById('files').addEventListener('change', handleFileChange, false);
</script>

 </body>
</html>